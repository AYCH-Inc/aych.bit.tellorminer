package pow

//this command generates a go file containing the complete opencl source as a string constant
//allows the opencl sources to be burned into the miner executable
//AND fixes the problem with nvidia's compute cache not respecting #include statements
//go:generate go run generate_opencl.go


import (
	"fmt"
	"github.com/jgillich/go-opencl/cl"
	"math/big"
	"reflect"
	"unsafe"
)

type GpuMiner struct {
	//number of threads in a workgroup
	localSize int
	//total number of threads
	globalSize int
	//number of iterations within a thread
	count uint32

	//opencl driver state
	context *cl.Context
	queue *cl.CommandQueue
	kernel *cl.Kernel

	name string

	//gpu buffers
	prefix, mulDivisor, output *cl.MemObject
}

func GetOpenCLGPUs() ([]*cl.Device, error) {
	platforms, err := cl.GetPlatforms()
	if err != nil {
		return nil, err
	}
	gpus := []*cl.Device{}
	for _,platform := range platforms {
		devices, err := platform.GetDevices(cl.DeviceTypeGPU)
		if err != nil {
			return nil, fmt.Errorf("failed to get devices for platform %s: %s", platform.Name(), err.Error())
		}
		gpus = append(gpus, devices...)
	}
	return gpus, nil
}

//prepare an openCL device for work
func NewGpuMiner(device *cl.Device) (*GpuMiner, error) {

	var g GpuMiner
	var err error
	g.count = 512
	g.localSize = 64
	g.globalSize = 64*g.localSize
	g.name = device.Name()
	g.context, err = cl.CreateContext([]*cl.Device{device})
	if err != nil {
		return nil, fmt.Errorf("CreateContext failed: %+v", err)
	}
	g.queue, err = g.context.CreateCommandQueue(device, 0)
	if err != nil {
		return nil, fmt.Errorf("CreateCommandQueue failed: %+v", err)
	}
	program, err := g.context.CreateProgramWithSource([]string{KernelSource})
	if err != nil {
		return nil, fmt.Errorf("CreateProgramWithSource failed: %+v", err)
	}
	if err := program.BuildProgram(nil, "-Werror"); err != nil {
		return nil, fmt.Errorf("BuildProgram failed: %+v", err)
	}
	g.kernel, err = program.CreateKernel("tellor")
	if err != nil {
		return nil, fmt.Errorf("CreateKernel failed: %+v", err)
	}

	g.prefix, err = g.context.CreateEmptyBuffer(cl.MemReadOnly, 56)
	if err != nil {
		return nil, fmt.Errorf("CreateBuffer failed for prefix: %+v", err)
	}
	g.mulDivisor, err = g.context.CreateEmptyBuffer(cl.MemReadOnly, 128)
	if err != nil {
		return nil, fmt.Errorf("CreateBuffer failed for mulDivisor: %+v", err)
	}
	g.output, err = g.context.CreateEmptyBuffer(cl.MemWriteOnly, 16)
	if err != nil {
		return nil, fmt.Errorf("CreateBuffer failed for output: %+v", err)
	}
	return &g, nil
}

func (g *GpuMiner)Name() string {
	return g.name
}

func (g *GpuMiner)CheckRange(hash *HashSettings,  start uint64, n uint64) (string, error) {
	if n % g.StepSize() != 0 {
		return "", fmt.Errorf("n (%d) must be a multiple of GPU step size (%d)", n, g.StepSize())
	}
	mulDivisorBytes := createDivisorByteArray(hash.difficulty)

	_, err := g.queue.EnqueueWriteBuffer(g.prefix, true, 0, len(hash.prefix), unsafe.Pointer(&hash.prefix[0]), nil)
	if err != nil {
		return "", fmt.Errorf("EnqueueWriteBuffer failed: %+v", err)
	}
	_, err = g.queue.EnqueueWriteBuffer(g.mulDivisor, true, 0, len(mulDivisorBytes), unsafe.Pointer(&mulDivisorBytes[0]), nil)
	if err != nil {
		return "", fmt.Errorf("EnqueueWriteBuffer failed: %+v", err)
	}

	done := uint64(0)
	for done < n {
		if err := g.kernel.SetArgs(g.prefix, g.mulDivisor, g.output, start, g.count); err != nil {
			return "", fmt.Errorf("SetKernelArgs failed: %+v", err)
		}

		if _, err := g.queue.EnqueueNDRangeKernel(g.kernel, nil, []int{g.globalSize}, []int{g.localSize}, nil); err != nil {
			return "", fmt.Errorf("EnqueueNDRangeKernel failed: %+v", err)
		}

		//not 100% sure this is needed
		//if err := g.queue.Finish(); err != nil {
		//	return "", fmt.Errorf("Finish failed: %+v", err)
		//}

		//16 byte nonce generated by gpu
		results := make([]byte, 16)
		if _, err := g.queue.EnqueueReadBuffer(g.output, true, 0, len(results), unsafe.Pointer(&results[0]), nil); err != nil {
			return "", fmt.Errorf("EnqueueReadBuffer failed: %+v", err)
		}

		if results[0] != 0 {
			return string(results), nil
		}
		start += g.StepSize()
		done += g.StepSize()
	}
	return "", nil
}

//number of hashes this backend checks at a time
func (g *GpuMiner)StepSize() uint64 {
	return uint64(g.globalSize)*uint64(g.count)
}


func getBigWordArray(x []byte) []big.Word {
	// Get the slice header
	header := *(*reflect.SliceHeader)(unsafe.Pointer(&x))

	// The length and capacity of the slice are different.
	header.Len /= 8
	header.Cap /= 8

	// Convert slice header to an []uint32
	return *(*[]big.Word)(unsafe.Pointer(&header))
}


func fullBigInt(n int) *big.Int {
	b := make([]byte, n, n)
	for i := 0; i < n; i++ {
		b[i] = 0xff
	}
	x := new(big.Int)
	x.SetBytes(b)
	return x
}

// quickly check divisibility using a multiply by a precomputed constant
// see https://lemire.me/blog/2019/02/08/faster-remainders-when-the-divisor-is-a-constant-beating-compilers-and-libdivide/
func createDivisorByteArray(d *big.Int) []byte {
	c := fullBigInt(64)
	bigone := big.NewInt(1)
	c.Div(c, d)
	c.Add(c, bigone)
	cSub1 := new(big.Int)
	cSub1.Sub(c, bigone)

	result := make([]byte, 128, 128)
	copy(getBigWordArray(result), c.Bits())
	copy(getBigWordArray(result)[8:], cSub1.Bits())

	return result
}



